---
title: "epifriends_on_different_distributions"
author: "Mikel Majewski"
date: '2022-10-21'
output:
  pdf_document: default
  html_document: default
---

## Importing modules

We first import the packages required from this RMarkdown.

```{r}
library("RANN")
library("data.table")
library("readxl")
library("chron")
library("ggplot2")
library("patchwork")
library("ggpubr")
library("epifriends")
```

Auxiliar functions to be included in main package:

```{r}
clean_unknown_data <- function(positions, keep_null_tests,verbose){
  # This method removes all the cases with any missing value
  # in either x or y.
  #
  # Parameters:
  # -----------
  # positions: list of class data.table
  #   A list with the position parameters we want to query with shape (n,2),
  #   where n is the number of positions.
  # keep_null_tests: numeric of logical
  #   Whether to remove or not missings. If numeric, provide value to impute.
  # verbose: logical
  #   If TRUE, print information of the process; else, do not print.
  #
  # Returns:
  # --------
  # indeces: List of class data.table
  #   List with imputed or removed missing values.
  
  #Change infinites to missings
  positions[sapply(positions, is.infinite)] <- NA
  
  if(is.numeric(keep_null_tests)){
    if(verbose){print(paste0(
      "Replacing missing positions with value: ",as.character(keep_null_tests))
    )}
    positions <- data.table::setnafill(positions, fill=keep_null_tests)
  }else if(keep_null_tests == FALSE){
    positions <- positions[!(is.na(x) | is.na(y))]
  }else if(keep_null_tests == TRUE){
    if(verbose){print("Missing values in positions kept as NULL")}
  }else{
    stop("Argument keep_null_tests has an invalid argument")
  }
  
  return(positions)
  
}
```
  
Some functions in order to plot are defined:

```{r}
scatter_pval <- function(coordinates, id_data, positive, epi_catalogue){
    # This method shows a scatter plot of the data distribution, showing in 
    # colour the positive cases that belong to foci (with the colour 
    # representing their p-value) and in grey the rest of the data. 
    # 
    # Parameters:
    # -----------
    # coordinates: data.frame
    #     data frame with the values of the coordinates
    # id_data: data.frame
    #     data frame with the cluster ID associated to each positive case, o for 
    #     no associated cluster
    # positive: data.frame
    #     Boolean vector that indicates if the case is infected. 
    # epi_catalogue: list
    #     List of the EpiFRIenDs catalogue
    # 
    # Returns:
    # --------
    # Scatter plot of the data distribution, showing in 
    # colour the positive cases that belong to foci (with the colour 
    # representing their p-value) and in grey the rest of the data.
    pos <- data.frame(coordinates[positive,],id_data)
    p_vals <- c()
    for(i in id_data[id_data > 0]){
      p_vals <- append(p_vals, epi_catalogue$p[epi_catalogue$id == i])
    }
    # plot(coordinates$x, coordinates$y, pch = 19, col = "grey")
    # points(pos$x[id_data > 0], pos$y[id_data>0], pch = 19, col = rainbow(100)[factor(p_vals)])
    graph <- ggplot(coordinates,aes(x=x, y=y))+
            geom_point(color = "grey", size = 2.5)+
            geom_point(data = pos[id_data >0,], aes(colour = p_vals), size = 2.5)+
            scale_color_gradientn(colors = c("#00AFBB", "#E7B800", "#FC4E07"))+
            ggtitle("P-value of hotspots")
    return(graph)
}
#cat$epifriends_catalogue$p[cat$epifriends_catalogue$id != 0]
```

```{r}
scatter_pr <- function(coordinates, id_data, positive, epi_catalogue){
    # This method shows a scatter plot of the data distribution, showing in 
    # colour the positive cases that belong to foci (with the colour 
    # representing their p-value) and in grey the rest of the data. 
    # 
    # Parameters:
    # -----------
    # coordinates: data.frame
    #     data frame with the values of the coordinates
    # id_data: data.frame
    #     data frame with the cluster ID associated to each positive case, o for 
    #     no associated cluster
    # positive: data.frame
    #     Boolean vector that indicates if the case is infected. 
    # epi_catalogue: list
    #     List of the EpiFRIenDs catalogue
    # 
    # Returns:
    # --------
    # Scatter plot of the data distribution, showing in 
    # colour the positive cases that belong to foci (with the colour 
    # representing their p-value) and in grey the rest of the data.
    pos <- data.frame(coordinates[positive,],id_data)
    pr <- c()
    for(i in id_data[id_data > 0]){
      pr <- append(pr, epi_catalogue$mean_pr[epi_catalogue$id == i])
    }
    # plot(coordinates$x, coordinates$y, pch = 19, col = "grey")
    # points(pos$x[id_data > 0], pos$y[id_data>0], pch = 19, col = rainbow(100)[factor(p_vals)])
    graph <- ggplot(coordinates,aes(x=x, y=y))+
            geom_point(color = "grey", size = 2.5)+
            geom_point(data = pos[id_data >0,], aes(colour = pr), size = 2.5)+
            scale_color_gradientn(colors = c("#00AFBB", "#E7B800", "#FC4E07"))+
            ggtitle("PR of hotspots")
    return(graph)
}
#cat$epifriends_catalogue$p[cat$epifriends_catalogue$id != 0]
```

```{r}
size_histogram <- function(catalogue){
  # This method shows a histogram of the size (total number of cases) in foci 
  # for foci with p>0.05 and with p<0.05. 
  #   
  # Parameters:
  # -----------
  # catalogue: list
  #   List of the EpiFRIenDs catalogue
  #   
  # Returns:
  # --------
  # Histogram of number of foci per total number of cases with p<0.05 in red 
  # and p>0.05 in blue.
  cases <- data.frame(catalogue$epifriends_catalogue$total, catalogue$epifriends_catalogue$p)
  colnames(cases) <- c("total","p")
  #auxiliar vector to avoid converting doubles to strings
  aux <- cases$p
  for(i in 1:length(cases$p)){
    if(aux[i] > 0.05){
      cases$p[i] <- "p > 0.05"
    }else{
      cases$p[i] <- "p < 0.05"
    }
  }
  histo <- ggplot(cases,aes(x=total, fill=p))+
          geom_histogram()+
          scale_fill_manual(values = c("red", "blue"))+
          xlab("Number of cases in focci")+
          ylab("Number of focci")
  return(histo)
}
```

## Create mock data 

The data created with the epifriends_on_different_distributions.ipynb file of python and saved on this R project is readed:


```{r, warning=FALSE}
setwd("./../")
datarand <- data.table(read.csv("./data/mock_data_rand.csv"))
datasin <- data.table(read.csv("./data/mock_data_sin.csv"))
dataclus <- data.table(read.csv("./data/mock_data_clustered.csv"))

# Set some random missings
datarand[X %in% sample(X, 5, TRUE), x := NA]
datasin[X %in% sample(X, 5, TRUE), y := NA]
dataclus[X %in% sample(X, 5, TRUE), x := NA]
dataclus[X %in% sample(X, 5, TRUE), y := NA]

# Clean missings
datarand <- clean_unknown_data(datarand, FALSE,FALSE)
datasin <- clean_unknown_data(datasin, FALSE,FALSE)
dataclus <- clean_unknown_data(dataclus, FALSE,FALSE)
```

In order to work better with the data, some subdatasets are created:

```{r}
position_rand <- datarand[,3:4]
positive_rand = (datarand$test == 1)
test_rand <- datarand[,5]

position_sin <- datasin[,3:4]
positive_sin = (datasin$test == 1)
test_sin <- datasin[,5]

position_clus <- dataclus[,3:4]
positive_clus = (dataclus$test == 1)
test_clus <- dataclus[,5]
```

This is the spatial distribution of negative (in black) and positive (in red) cases of the three mock data catalogues created:

```{r}
plot(datarand$x, datarand$y, pch = 19, col = as.factor(datarand$test))
plot(datasin$x, datasin$y, pch = 19, col = as.factor(datasin$test))
plot(dataclus$x, dataclus$y, pch = 19, col = as.factor(dataclus$test))
```

## Running EpiFRIenDs 

We first define the two main parameters of the method: 

- **link_d**, the linking distance: this distance is used to link the data points so that points that are closer than this distance are candidates to join and form part of the same cluster. The other parameter, **min_neighbours**, defines if they are actually linked. 

- **min_neighbours**, the minimum number of neighbours: one data point is linked to its neighbours (or friends, defined as the data points closer than **link_d** to it) only if there are at least **min_neighbours** (including itself) to link. This parameter ensures that for each cluster we have at least **min_neighbours** within a radius of **link_d**, plus other data points indirectly linked to them. 

```{r}
link_d = 0.01
min_neighbours = 2
```

The function **dbscan** uses these two parameters to identify clusters using the Density-based spatial clustering of applications with noise (DBSCAN) algorithm and returns the cluster ID of each data point, with 0 meaning that the data point does not belong to any cluster. In the EpiFRIenDs algorithm, DBSCAN is applied using only the positive cases in order to detect clusters of infections. In the following example, we select the positions of th first mock dataset of the positive cases only using the mask **positive_rand**, a boolean array indicating if the case is positive. We visualise the result showing the scatter distribution of negative cases in grey and the distribution of positive cases colour coded by the cluster ID (0 meaning that they are not assigned to any cluster).

```{r}
#Running DBSCAN for the mock data with random distribution
cluster_id = dbscan(position_rand[positive_rand,], link_d, min_neighbours)

neg <- data.frame(position_rand[!positive_rand,])
pos <- data.frame(position_rand[positive_rand,],cluster_id)
# 
# plot(datarand$x[!positive_rand], datarand$y[!positive_rand], pch = 19, col = "grey")
# points(datarand$x[positive_rand], datarand$y[positive_rand], pch = 19, col = rainbow(40)[factor(cluster_id)])
graph <- ggplot(neg,aes(x=x, y=y))+
            geom_point(color = "grey", size = 2.5)+
            geom_point(data = pos, aes(colour = cluster_id), size = 2.5)+
            scale_colour_gradientn(colors=c("black",rainbow(7)))
graph

```


```{r}
#Running DBSCAN for the mock data with sinusoidal distribution
cluster_id = dbscan(position_sin[positive_sin,], link_d, min_neighbours)

neg <- data.frame(position_sin[!positive_sin,])
pos <- data.frame(position_sin[positive_sin,],cluster_id)

# plot(datasin$x[!positive_sin], datasin$y[!positive_sin], pch = 19, col = "grey")
# points(datasin$x[positive_sin], datasin$y[positive_sin], pch = 19, col = rainbow(40)[factor(cluster_id)])

graph <- ggplot(neg,aes(x=x, y=y))+
            geom_point(color = "grey", size = 2.5)+
            geom_point(data = pos, aes(colour = cluster_id), size = 2.5)+
            scale_colour_gradientn(colors=c("black",rainbow(50)))
graph
```

```{r}
#Running DBSCAN for the mock data with cluster distribution
cluster_id = dbscan(position_clus[positive_clus,], link_d, min_neighbours)

neg <- data.frame(position_clus[!positive_clus,])
pos <- data.frame(position_clus[positive_clus,],cluster_id)

# plot(dataclus$x[!positive_clus], dataclus$y[!positive_clus], pch = 19, col = "grey")
# points(dataclus$x[positive_clus], dataclus$y[positive_clus], pch = 19, col = rainbow(40)[factor(cluster_id)])

graph <- ggplot(neg,aes(x=x, y=y))+
            geom_point(color = "grey", size = 2.5)+
            geom_point(data = pos, aes(colour = cluster_id), size = 2.5)+
            scale_colour_gradientn(colors=c("black",rainbow(40)))
graph
```

The main method from EpiFRIenDs is the function catalogue, that adds the neighbouring negative cases into the clusters by connecting the negative cases into the clusters when they are closer than link_d to at least one of the positive cases of each cluster. Notice that, with this approach, one negative case can contribute to two different clusters, since it can be closer than link_d to two positive cases from two different clusters that are furthen than link_d between them.

catalogue requires as input the positions and test results of the whole data set and the linking distance link_d. Optionally, the cluster IDs of the positive cases obtained from the method dbscan can be passed as input, otherwise dbscan is run on the positive cases as the first step of the function catalogue. Finally, min_neighbours can also be specified. The default value is 2, corresponding to the case of running the Friends-of-Friends algorithm on the positive cases in the dbscan step.

The method outputs the cluster ID, positivity rate and p-value assigned to each positive case, as well as a geopandas dataframe with the EpiFRIenDs output catalogue, with the following information:

    'id': EpiFRIenDs id of the foci
    'mean_position_pos': Mean position of positive cases
    'mean_position_all': Mean position of all cases
    'mean_pr': Positivity rate of the foci
    'positives': Number of positive cases
    'negatives': Number of negative cases
    'total': Total number of positions
    'indeces': Indeces of all positions
    'p': p-value of the detection

In the following example we run the method catalogue for different values of link_d in order to see the impact of this parameter on the detected foci (or clusters).

```{r}
#EpiFRIenDs parameters
link_d_to_analyse = c(.01, .02, .05, .1)
min_neighbours = 2
```

We run EpiFRIenDs for all values or `link_d` and for the three mock data catalogues. 

Here we show the results of applying different `link_d` to the first mock catalogue with random distributions:

```{r}
#Random distribution
for(link_d in link_d_to_analyse){
  cat_rand <- catalogue(position_rand, test_rand, link_d, cluster_id = NULL, min_neighbours = min_neighbours)
  print(paste0("Number of EpiFRIenDs groups in random data with scale = ", link_d, ":", length(cat_rand$epifriends_catalogue$id), ", ", sum(cat_rand$epifriends_catalogue$p < 0.05), " of which with p<0.05"))
  graph_rand <- scatter_pval(position_rand, cat_rand$cluster_id, positive_rand, cat_rand$epifriends_catalogue)
  histo_rand <- size_histogram(cat_rand)
  print(graph_rand + histo_rand)
}
```

Now this shows the results applied to the data set with a sinusoidal distribution of positive cases: 

```{r}
#Random distribution
for(link_d in link_d_to_analyse){
  cat_sin <- catalogue(position_sin, test_sin, link_d, cluster_id = NULL, min_neighbours = min_neighbours)
  print(paste0("Number of EpiFRIenDs groups in sinusoidal data with scale = ", link_d, ":", length(cat_sin$epifriends_catalogue$id), ", ", sum(cat_sin$epifriends_catalogue$p < 0.05), " of which with p<0.05"))
  graph_sin <- scatter_pval(position_sin, cat_sin$cluster_id, positive_sin, cat_sin$epifriends_catalogue) 
  histo_sin <- size_histogram(cat_sin)
  print(graph_sin+histo_sin)
}
```

Finally, this shows the results applied to the data set with clustered distribution of positive cases: 

```{r}
#Random distribution
for(link_d in link_d_to_analyse){
  cat_clus <- catalogue(position_clus, test_clus, link_d, cluster_id = NULL, min_neighbours = min_neighbours)
  print(paste0("Number of EpiFRIenDs groups in sinusoidal data with scale = ", link_d, ":", length(cat_clus$epifriends_catalogue$id), ", ", sum(cat_clus$epifriends_catalogue$p < 0.05), " of which with p<0.05"))
  graph_clus <- scatter_pval(position_clus, cat_clus$cluster_id, positive_clus, cat_clus$epifriends_catalogue) 
  histo_clus <- size_histogram(cat_clus)
  print(graph_clus+histo_clus)
}
```

