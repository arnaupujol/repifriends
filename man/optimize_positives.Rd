% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/automate_link_d.R
\name{optimize_positives}
\alias{optimize_positives}
\title{This method optimizes the linking distance based on the distribution of the minimum distances that satisfy a given
minimum neighbor restriction.}
\usage{
optimize_positives(
  position,
  test_result,
  min_neighbors,
  cluster_id,
  min_distances,
  quantiles,
  thr_impr = 0.05,
  diff_quantile = 0.05,
  keep_null_tests = FALSE,
  in_latlon = FALSE,
  to_epsg = NULL
)
}
\arguments{
\item{cluster_id}{Numeric vector with the cluster IDs of each position, with 0 for those without a cluster. Give NULL if cluster_id must be calculated.}

\item{thr_impr}{Percentage of improvement of the optimization metric to keep iterating.}

\item{diff_quantile}{Step increase/decrease of best quantile to avoid local minima.}

\item{keep_null_tests}{Whether to remove or not missings. If numeric, provide value to impute.}

\item{df}{data.table with coordinates and test results.}

\item{min_neighbours}{Minium number of neighbours in the radius < link_d needed to link cases as friends.}

\item{dist_prop}{Distance threshold to merge two quantiles due to proximity.}

\item{quantile_est}{If 'fixed', quantiles used will be from 0 to 1 with a step of 0.125. If 'random', a random estimation of the step will be done.}

\item{in_latlon:}{If True, x and y coordinates are treated as longitude and latitude respectively, otherwise they are treated as cartesian coordinates.}

\item{to_epsg:}{If in_latlon is True, x and y are reprojected to this EPSG.}

\item{verbose:}{If TRUE, print information of the process; else, do not print.}
}
\value{
List with linking_distance & trace of iterations
}
\description{
This method optimizes the linking distance based on the distribution of the minimum distances that satisfy a given
minimum neighbor restriction.
}
\examples{
# Required packages
if(!require("RANN")) install.packages("RANN")
library("RANN")

# Creation of x vector of longitude coordinates, y vector of latitude coordinates and finaly merge them on a position data frame.
x <- c(1,2,3,4,7.5,8,8.5,9,10,13,13.1,13.2,13.3,14,15,30)
y <- c(1,2,3,4,7.5,8,8.5,9,10,13,13.1,13.2,13.3,14,15,30)
pos <- data.frame(x,y)

# Creation of test data frame with 0 for negative cases and 1 for positive clases for each position.
test <- data.frame(c(0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,1))

min_distances <- c(0.01, 0.02, 0.05, 0.02, 0.07, 0.08, 0.01, 0.02)

# Creation of catalogue for this positions, linking distance 2 and default values.
link_d_list <- optimize_positives(pos, test, 2, NULL, min_distances)

}
\author{
Eric Matamoros.
}
